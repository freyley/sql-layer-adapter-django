import re

from django import VERSION as djangoVersion
from django.db.backends import BaseDatabaseOperations

# This DatabaseOperations class lives in here instead of base.py because it's
# used by both the 'postgresql' and 'postgresql_psycopg2' backends.

class DatabaseOperations(BaseDatabaseOperations):
    def __init__(self, connection):
        if djangoVersion[0:2] >= (1,4):
            super(DatabaseOperations, self).__init__(connection)
        else:
            super(DatabaseOperations, self).__init__()
            self.connection = connection

    def date_extract_sql(self, lookup_type, field_name):
        # FoundationDB has YEAR, MONTH and DAY extraction functions
        known_funcs = ['year', 'month', 'day']
        if lookup_type not in known_funcs:
            raise "Unknown lookup_type: %s" % (lookup_type,)
        return '%s("%s")' % (lookup_type, field_name)

    def date_interval_sql(self, sql, connector, timedelta):
        """
        implements the interval functionality for expressions
        format for Postgres:
            (datefield + interval '3 days 200 seconds 5 microseconds')
        """
        modifiers = []
        if timedelta.days:
            modifiers.append(u'%s days' % timedelta.days)
        if timedelta.seconds:
            modifiers.append(u'%s seconds' % timedelta.seconds)
        if timedelta.microseconds:
            modifiers.append(u'%s microseconds' % timedelta.microseconds)
        mods = u' '.join(modifiers)
        conn = u' %s ' % connector
        return u'(%s)' % conn.join([sql, u'interval \'%s\'' % mods])

    def date_trunc_sql(self, lookup_type, field_name):
        # For an input of YYYY-MM-DD HH:MM:SS, this needs to take a lookup
        # of year, month or day to YYYY-01-01, YYYY-MM-01 or YYYY-MM-DD, respectively
        formats = { 'year': '%Y-01-01', 'month': '%Y-%m-01', 'day': '%Y-%m-%d' }
        fmt_str = formats.get(lookup_type, None)
        if fmt_str is None:
            raise "Unknown lookup_type: %s" % (lookup_type,)
        return 'DATE_FORMAT(%s, %s)' % (self.quote_name(field_name), fmt_str)

    # TODO
    #def last_insert_id(self, cursor, table_name, pk_name):
    #    # Use pg_get_serial_sequence to get the underlying sequence name
    #    # from the table name and column name (available since PostgreSQL 8)
    #    cursor.execute("SELECT CURRVAL(pg_get_serial_sequence('%s','%s'))" % (
    #        self.quote_name(table_name), pk_name))
    #    return cursor.fetchone()[0]

    def no_limit_value(self):
        return None

    def quote_name(self, name):
        if name.startswith('"') and name.endswith('"'):
            return name # Quoting once is enough.
        return '"%s"' % name

    # TODO
    #def sql_flush(self, style, tables, sequences):
    #    if tables:
    #        if self.postgres_version[0:2] >= (8,1):
    #            # Postgres 8.1+ can do 'TRUNCATE x, y, z...;'. In fact, it *has to*
    #            # in order to be able to truncate tables referenced by a foreign
    #            # key in any other table. The result is a single SQL TRUNCATE
    #            # statement.
    #            sql = ['%s %s;' % \
    #                (style.SQL_KEYWORD('TRUNCATE'),
    #                 style.SQL_FIELD(', '.join([self.quote_name(table) for table in tables]))
    #            )]
    #        else:
    #            # Older versions of Postgres can't do TRUNCATE in a single call, so
    #            # they must use a simple delete.
    #            sql = ['%s %s %s;' % \
    #                    (style.SQL_KEYWORD('DELETE'),
    #                     style.SQL_KEYWORD('FROM'),
    #                     style.SQL_FIELD(self.quote_name(table))
    #                     ) for table in tables]

    #        # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
    #        # to reset sequence indices
    #        for sequence_info in sequences:
    #            table_name = sequence_info['table']
    #            column_name = sequence_info['column']
    #            if not (column_name and len(column_name) > 0):
    #                # This will be the case if it's an m2m using an autogenerated
    #                # intermediate table (see BaseDatabaseIntrospection.sequence_list)
    #                column_name = 'id'
    #            sql.append("%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % \
    #                (style.SQL_KEYWORD('SELECT'),
    #                style.SQL_TABLE(self.quote_name(table_name)),
    #                style.SQL_FIELD(column_name))
    #            )
    #        return sql
    #    else:
    #        return []

    #def sequence_reset_sql(self, style, model_list):
    #    from django.db import models
    #    output = []
    #    qn = self.quote_name
    #    for model in model_list:
    #        # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
    #        # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
    #        # if there are records (as the max pk value is already in use), otherwise set it to false.
    #        # Use pg_get_serial_sequence to get the underlying sequence name from the table name
    #        # and column name (available since PostgreSQL 8)

    #        for f in model._meta.local_fields:
    #            if isinstance(f, models.AutoField):
    #                output.append("%s setval(pg_get_serial_sequence('%s','%s'), coalesce(max(%s), 1), max(%s) %s null) %s %s;" % \
    #                    (style.SQL_KEYWORD('SELECT'),
    #                    style.SQL_TABLE(qn(model._meta.db_table)),
    #                    style.SQL_FIELD(f.column),
    #                    style.SQL_FIELD(qn(f.column)),
    #                    style.SQL_FIELD(qn(f.column)),
    #                    style.SQL_KEYWORD('IS NOT'),
    #                    style.SQL_KEYWORD('FROM'),
    #                    style.SQL_TABLE(qn(model._meta.db_table))))
    #                break # Only one AutoField is allowed per model, so don't bother continuing.
    #        for f in model._meta.many_to_many:
    #            if not f.rel.through:
    #                output.append("%s setval(pg_get_serial_sequence('%s','%s'), coalesce(max(%s), 1), max(%s) %s null) %s %s;" % \
    #                    (style.SQL_KEYWORD('SELECT'),
    #                    style.SQL_TABLE(qn(f.m2m_db_table())),
    #                    style.SQL_FIELD('id'),
    #                    style.SQL_FIELD(qn('id')),
    #                    style.SQL_FIELD(qn('id')),
    #                    style.SQL_KEYWORD('IS NOT'),
    #                    style.SQL_KEYWORD('FROM'),
    #                    style.SQL_TABLE(qn(f.m2m_db_table()))))
    #    return output

    #def check_aggregate_support(self, aggregate):
        #raise NotImplementedError('Aggregate not supported: %s' % (aggregate,))

    def max_name_length(self):
    	return 128

    def lookup_cast(self, lookup_type):
        lookup = '%s'
        # Transform field like term is. Needs to match operations dict in base.py/DatabaseWrapper.
        if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
            lookup = 'UPPER(%s)' % lookup
        return lookup

    # Added in Django 1.4
    def bulk_insert_sql(self, fields, num_values):
        items_sql = "(%s)" % ", ".join(["%s"] * len(fields))
        return "VALUES " + ", ".join([items_sql] * num_values)

